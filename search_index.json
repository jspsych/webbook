[["index.html", "Online Behavioral Experiments with jsPsych Welcome", " Online Behavioral Experiments with jsPsych Joshua R. de Leeuw Welcome This book will teach you how to create behavioral experiments using jsPsych. jsPsych is a JavaScript-based framework for developing experiments that run in a web browser. Any device with a modern web browser installed (e.g., desktops, laptops, tablets, and mobile phones) can run jsPsych experiments. Experiments can be delivered via a web server for online participants, or run locally on a computer in a laboratory. Each chapter of this book illustrates a key feature or set of related features of jsPsych by walking you through the creation of a real experiment from the cognitive science literature. If you are brand new to jsPsych (or web-based programming in general), it’s recommended that you work through the chapters in order. Experiments later in the book build off the concepts introduced by earlier experiments. If you are already familiar with jsPsych and are looking to learn about a specific technique, each chapter should be sufficiently self-contained that you can jump around. This book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Suggestions, requests for clarification, corrections, and contributions are welcome! Please use the Issue Tracker in the book’s GitHub repository or open a pull request. This book is written in RMarkdown with bookdown. "],["programming-for-the-web.html", "1 Programming for the Web", " 1 Programming for the Web This chapter provides a conceptual overview of programming for the web. It is intended for readers who have done little or no web development. It covers the core concepts of web-based programming, which can be mysterious for new web developers. It also explains how websites are published and gives some advice about the tools that you will want to have on your computer to support effective web development. This chapter won’t teach you how to program. However, it should make learning to program a bit easier by clarifying how all the pieces of a website interact together. This chapter does aim to give you enough background knowledge that you can start building the experiments in this book. One way to learn how to program for the web is to build the experiments in this book, tinkering with them to test and extend your knowledge. Another approach is to read this chapter for the overview and then invest some time learning the basics of programming for the web by completing one of the many high-quality online courses/tutorials. I won’t try and provide specific course and tutorial recommendations here, given how frequently they appear and change, but a quick search should be sufficient to find many good options. "],["how-a-website-works.html", "1.1 How a website works", " 1.1 How a website works When you open a browser and type in the URL of this book (http://book.jspsych.org) lots of things have to happen in order for you to see the website. A connection is established between your computer and another computer that “serves” the website. One or more files are then transferred from the server to your computer. These files include HTML documents, CSS stylesheets, JavaScript files, and media elements like audio files and images. As a developer, your role is to create all of the files that are needed to render the website as you want it. A crticial point to remember as a new web developer is that it is the job of the web browser to transform this set of files into a website. As a developer, you are providing a (very detailed) “recipe” and the browser is assembling the final dish. This might seem a bit troubling. If three chefs were given the same recipe the results might be noticably different. Fortunately, browsers are far more precise than chefs and usually websites look the same regardless of which browser is doing the rendering. This is thanks to a commonly agreed upon set of standards that browser developers follow. However, these standards have some ambiguity and as a result there are times when a website will look exactly like you want it to in one browser but not in another. 1.1.1 “Front end” and “Back end” Two (or more) computers are involved when a website is requested: The computer that the viewer of the website is using and one or more computers that are serving the website. Programming for the web is conceptually divided based on which of the computers is running the code. If the code is running on the viewer’s computer, it’s front-end development. If it is running on the computer serving the website, it’s back-end development. This chapter focuses on front-end web development. This kind of web development focuses on what the viewer of the website sees and how they interact with the website. It involves HTML, CSS, and JavaScript. Back-end development is focused on programs that run on the computer(s) serving the website. These programs typically handle tasks that require access to data stored on the server. For data-rich websites, most of the programming is back-end focused. There are many programming languages that can be used for back-end development. For a typical online experiment, most of the programming is focused on the front end. As researchers, we need to control what the user is seeing or hearing, and how they are interacting with the experiment. These are tasks that are controlled by front-end development. One aspect of back-end programming that experiments do need to handle is data storage. JavaScript (running on the participant’s computer) can record data from an experiment, but in order to store the data on the researcher’s server back-end programming is necessary. Fortunately, these back-end scripts are interchangeable for jsPsych experiments. [Chapter X] provides a sample data saving script that should work for any jsPsych experiment. "],["three-languages-of-the-web.html", "1.2 Three languages of the web", " 1.2 Three languages of the web One of the challenging aspects of web development is that the programmer needs to know three different languages: HTML, CSS, and JavaScript. Each language is responsible for a different kind of information that the web browser needs in order to render the final website. HTML defines the structure of the elements on a website, such as the presence of text and images. CSS controls how those elements look. If you want to change the size of an image, the color of a background, or the font of a paragraph, you’ll be using CSS. HTML and CSS are both markup languages. [Need description of what that means]. JavaScript, on the other hand, is a true programming language. In addition to all the normal kinds of computation that programming langauges generally allow, JavaScript is especially good at interacting with HTML and CSS. JavaScript can manipulate the HTML and CSS of a website, allowing the programmer to specify rules about when certain elements on the page should be added or removed (manipulating HTML) and when their appearance should change (manipulating CSS). These interactions can produce very simple results, such as changing the size of an image when the user clicks on it, or very complex ones, such as the development of a video game entirely in HTML, CSS, and JavaScript. To create a simple experiment in jsPsych, you only need to have a basic familiarity with JavaScript. There is minimal HTML and CSS in the first few experiments in this book. However, if you want maximal flexibility over what content is in the screen and how it appears, you will need to become familiar with HTML and CSS. As you will discover, jsPsych is designed to allow users who are comfortable manipulating HTML and CSS full control over the output. [possible figure here with two different jsPsych examples, one simple one fancy]. 1.2.1 HTML HTML (Hyper Text Markup Language) defines the elements that exist on a webpage. For example, the HTML below defines two paragraphs. &lt;p&gt;This is the text in paragraph one.&lt;/p&gt; &lt;p&gt;This is the text in paragraph two.&lt;/p&gt; HTML uses tags – like &lt;p&gt; and &lt;/p&gt; above – to define elements. The type of element is defined by the text in the tag. &lt;p&gt; tags create paragraphs, &lt;img&gt; tags create images, and &lt;audio&gt; tags create audio. Elements begin with the type of element in &lt; &gt; brackets, and end with the same tag plus a backslash: &lt;/ &gt;. HTML defines a lot of different elements. [maybe a link here?]. But you don’t need to know all or even most of these to get started with HTML. As long as you understand a few ideas about how to use HTML, you’ll be able to understand HTML markup and modify it to suit your needs. 1.2.1.1 HTML attributes HTML tags often have additional attributes that control additional properties of the element. One attribute of the &lt;img&gt; tag is the src, which defines the source of the image. The &lt;img&gt; tag below has the src attribute set to the URL of the jsPsych logo. &lt;img src=&quot;https://www.jspsych.org/img/jspsych-logo.jpg&quot;&gt;&lt;/img&gt; Attributes are declared by putting a space between the tag name and the attribute name and = after the attribute. The value to the right of the = will be assigned to that attribute. Tags can have multiple attributes separated by a space. The alt attribute for an img tag is used to describe the alternate text that would replace the image for users using screen readers or other assistive devices. &lt;img src=&quot;https://www.jspsych.org/img/jspsych-logo.jpg&quot; alt=&quot;jsPsych logo&quot;&gt;&lt;/img&gt; Two very useful attributes to know are id and class. These are both ways to identify elements on the page so that JavaScript and CSS can interact with them more easily. id values should typically be unique, and are used when CSS or JavaScript needs to target one particular element on a page. class values can be applied to many elements on a page, and are used when CSS or JavaScript needs to interact with all the instances of a particular set of elements. 1.2.1.2 Nesting elements in HTML Elements in HTML can be nested within other elements. For example, a link to another website may be nested within a paragraph. &lt;p&gt;Please see the &lt;a href=&quot;https://www.jspsych.org&quot;&gt;jsPsych documentation&lt;/a&gt; for more information.&lt;/p&gt; An important aspect of nesting elements is that the inner-most element (&lt;a&gt; above) must be closed before the element that contains it is closed. The following is wrong because the &lt;p&gt; element is closed before &lt;a&gt;, but &lt;a&gt; started after &lt;p&gt;. &lt;p&gt;Visit &lt;a href=&quot;https://www.jspsych.org&quot;&gt;jsPsych.org&lt;/p&gt;&lt;/a&gt; Nesting allows HTML to naturally reflect the hierarchical structure of a webpage. Webpages often have distinct sections, like navigation and content, that contain many elements. The &lt;div&gt; element is used to create arbitrary divisions of the page. &lt;div id=&quot;table-of-contents&quot;&gt; &lt;a href=&quot;chapter-1.html&quot;&gt;Chapter 1&lt;/a&gt; &lt;a href=&quot;chapter-2.html&quot;&gt;Chapter 2&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;p&gt;It all began...&lt;/p&gt; &lt;p&gt;And then ...&lt;/p&gt; &lt;p&gt;The end.&lt;/p&gt; &lt;/div&gt; 1.2.1.3 A bare-bones HTML document. If you create a text file with a few words in it, save it as a .html file, and open it in a web browser you’ll find that it is displayed as a web page. In some sense, a file of text is a minimal HTML file. However, most HTML files have a standard set of sections that look something like this. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;A bare-bones HTML document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; The above has a few HTML-elements, &lt;html&gt;, &lt;head&gt;, &lt;title&gt;, and &lt;body&gt;, as well as something that looks like an HTML element – &lt;!DOCTYPE html&gt; but is actually a declaration to the web browser about what kind of document this is and what the root element of the document is. In this case &lt;html&gt; serves as the root element, which is standard practice. &lt;head&gt; defines the head-section of the document, which can contain information about the page that is not directly rendered in the visible page. An example of this is the &lt;title&gt; element, which controls the title that is displayed in the window or tab of the web browser. &lt;body&gt; is the element that contains all of the content that will be displayed. 1.2.2 CSS CSS (Cascading Style Sheets) is a markup language that defines the visual appearance of elements on a webpage. For example, this CSS rule declares that all text in &lt;p&gt; tags will be displayed with a 24px font and in red. p { font-size: 24px; color: red; } CSS rules require the use of a selector. The selector defines the set of elements that the rule applies to. The selector appears before the {. In the above example, the selector applies the rule to all &lt;p&gt; elements. Any HTML element type can be used as a selector. For example, the following properties set the background color of the &lt;body&gt; element to black and the text color to white. body { background-color: black; color: white; } Two common selectors are selection by ID and by class. Recall that the HTML attribute id can be used to assign a unique name to an element, and the HTML attribute class can be used to group elements that share something in common together under a shared name. To apply a CSS rule to an element with a particular ID, the # symbol is placed before the ID. #table-of-contents { width: 500px; } To apply a CSS rule to all elements that belong to a particular class, the . symbol is placed before the class name. .navigation-link { color: blue; } Inside the { } appear a list of style rules that are applied to all elements that match the selector. The set of style rules is enormous, so the important thing is not to memorize different rules that could be applied, but rather to understand the concept of applying rules to elements based on selectors. 1.2.2.1 Where does CSS go in a document? There are three places where CSS typically appears in an HTML document. Each of these places is equally valid, and the choice of where to include CSS depends on what is easiest. Often CSS will exist in all three locations in a single document. 1.2.2.1.1 External CSS file One option is to create a separate .css file and load the file in the HTML document via a &lt;link&gt; tag in the &lt;head&gt; element. styles.css body { width: 600px; } p { font-size: 18px; font-weight: bold; } webpage.html &lt;head&gt; &lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;/link&gt; &lt;/head&gt; The &lt;link&gt; tag has a few attributes that need to be set. The href attribute is the path to the source file. This path is relative to the location of the .html file that the &lt;link&gt; is in. If the .html and .css files are in the same folder, then just the name of the .css file is sufficient. The rel and type attributes both describe what kind of content is being loaded. 1.2.2.1.2 &lt;style&gt; tag Another option is to include a &lt;style&gt; tag in the &lt;head&gt; element of the document. &lt;head&gt; &lt;style&gt; body { width: 600px; } p { font-size: 18px; font-weight: bold; } &lt;/style&gt; &lt;/head&gt; 1.2.2.1.3 style attribute HTML elements also support the style attribute, allowing styles to be set within the tag itself. &lt;body style=&quot;width:600px&quot;&gt; &lt;p style=&quot;font-size:18px; font-weight: bold;&quot;&gt;The start of a paragraph...&lt;/p&gt; &lt;/body&gt; This method is a little bit different than the first two, because there is no selector or { } to define the rule. That’s because the style attribute of an element only applies to that element. This method of adding style can be useful when there is only a single element that needs the style rule. This method is also used a lot by jsPsych because (as will become clear much later in the book) it is a relatively easy way to embed style information in JavaScript code that is generating HTML content. 1.2.3 JavaScript JavaScript is one of the most popular programming languages. Originally created to enable dynamic and interactive content in websites, JavaScript is now used for both websites and general purpose programming. JavaScript is still the dominant language of the web because it is understood by all the major web browsers and is enabled by default. Some of the things that you can do with JavaScript include: Changing HTML and CSS of a website in response to events. For example, a short JavaScript program make it so that when a user clicks a button an image on the page is changed to a new image. Controlling HTML and CSS will be one of the primary ways in which JavaScript is used when building online experiments. Recording data about how a user interacts with a webpage. JavaScript has access to information like what keys are being pressed on a keyboard and where the mouse is on the screen. It also has access to the time that these events occur. Sending and retrieving data from other applications on the web. For example, JavaScript can communicate with a database to store and access data. Learning JavaScript is a much bigger task than learning HTML or CSS, but you don’t need to master JavaScript to start using jsPsych. If you learn a few features of the language and understand how JavaScript interacts with HTML and CSS then you’ll be able to start programming the experiments in this book. 1.2.3.1 The JavaScript language 1.2.3.1.1 Comments In JavaScript, every bit of text is either a comment or code. Comments are there only for the benefit of the programmer or anyone else reading the code. They are ignored by the JavaScript engine. To comment text on a single line, use two forward slashes // // this is a comment To comment multiple lines of text, use /* at the start and */ at the end. /* this is a comment and so is this */ 1.2.3.1.2 Variables Variables are a way to store information. To store the value 3 in the variable x, we can do the following. var x = 3; var, short for variable, is how we declare that something is a variable. The = sign is called the assignment operator. In this case we would say that we are assigning the value 3 to the the variable x. In addition to numbers, two other common kinds of values that are assigned to variables are set of characters (called strings) and the boolean values true and false. Strings are created by placing the set of characters inside either single quotes ' ' or double quotes \" \". Either one is acceptable, but the starting and ending quote type need to match. var my_string = &#39;hello, reader!&#39;; var are_we_there_yet = false; Changing the value of a variable that already exists works almost the same as creating a variable, except that you don’t need the var keyword, because JavaScript already understands that the name refers to a variable. are_we_there_yet = true; 1.2.3.1.3 Arrays Arrays allow related data to be stored together in a single variable. var months_of_the_year = [&#39;January&#39;, &#39;February&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;, &#39;June&#39;, &#39;July&#39;, &#39;August&#39;, &#39;September&#39;, &#39;October&#39;, &#39;November&#39;, &#39;December&#39;]; They are created with square brackets [ ] and commas separating each value. Information in an array is accessed by putting the index of the desired position in the array inside the [ ]. To get the first item in the array: months_of_the_year[0]; // outputs &#39;January&#39; Note that array indices begin with 0, not 1. Though sometimes confusing, this is standard practice in most programming languages. 1.2.3.1.4 Objects Objects also allow related data to be stored together, but unlike arrays each bit of data in an object is named. var person = { name: &#39;John Doe&#39;, age: 35, employed: false } There are two primary ways to access the data stored in an object. Dot notation uses a . after the variable name. person.name; // outputs &#39;John Doe&#39; Bracket notation uses square brackets with the name of the property inside the brackets. person[&#39;name&#39;] // also outputs &#39;John Doe&#39; 1.2.3.1.5 Operators Operators perform assignment, arithmetic, comparison, or logical operations between different values. One operator that has already appeared above is the assignment operator, =. It takes the value on it’s right and stores it in the variable on the left. Values can be assigned to normal variables, arrays, or objects. var name = &#39;Jane&#39;; var person = {}; person.name = &#39;Jane&#39;; var people = []; people[0] = &#39;Jane&#39;; Arithmetic operators perform addition, subtraction, multiplication, and division: var four = 2 + 2; var five = 8 - 3; var six = 3 * 2; var seven = 21 / 3; Comparison operators are used to check if two values are equal, or if there is a particular kind of difference between values. == checks for equality 4 == 5; // false var four = 4; 4 == four; // true != checks for inequality 4 != 5; // true var four = 4; 4 != four; // false &gt; checks if the left value is greater than the right. &gt;= checks if the left value is greater than or equal to the value on the right. var four = 4; 4 &gt; four; // false 4 &gt;= four; // true &lt; checks if the left vaue is less than the right. &lt;= checks if the left value is less than or equal to the value on the right. var four = 4; four &lt; 5; // true 4 &lt; 3; // false Logical operators determine whether there is a particular relationship between values. &amp;&amp; checks if the value on the left AND the value on the right are both true. true &amp;&amp; true; // true 3 &gt; 2 &amp;&amp; 1 == 1; // true var three = 3; var five = 5; three &lt; 2 &amp;&amp; five &gt; 4; // false || checks if the value on the left OR the value on the right is true. true || false; // true; 3 &lt; 2 || 1 != 1; // false; var three = 3; var five = 5; three &lt; 2 || five &gt; 4; // true; ! inverts the truth value of whatever appears on the right. !(1 == 1); // false !(2 &lt; 1); // true var x = true; !x; // false 1.2.3.1.6 Functions Functions, sometimes also called methods, are self-contained sets of code that can be invoked through a name given to the function. // create a function function addTwo(x){ return x + 2; } // invoke the function addTwo(6); // outputs 8 Functions are created via the function keyword. Functions can have 0 or more parameters. In the example above, addTwo has one parameter called x. This parameter is defined by putting the desired name of the parameter inside the ( ) that occur immediately after the name of the function. Inside the body of the function, the code between the { }, x takes on whatever value is used when the function is called. If the function call is addTwo(6), then x is 6. If the function call is addTwo(1), x is 1. The output of a function is specified by the return keyword. In the addTwo function, the statement x + 2 is evaluated and the resulting value is the output of the function. The output can be stored in a variable. var output = addTwo(1); 1.2.3.1.7 Control Statements 1.2.3.2 JavaScript + HTML/CSS JavaScript is the tool that can turn a static website into an interactive one. JavaScript can alter the HTML and CSS of a website, allowing it to indirectly control what appears on the website and how it looks. There are several different approaches for using JavaScript to control the HTML and CSS of a website, and this section only covers a few of the most common. A powerful JavaScript function is .querySelector(). This function works in a similar way to CSS selectors. You can provide a selector, and the function will return the first HTML element that matches the selector. Unlike CSS selectors, with .querySelector you have to specify a root element, which is the HTML element that querySelector will search in. If you want to search the entire page, you can use the document root element. .querySelector() selects an HTML element, which can then be modified in a few different ways. One task that you might want to accomplish is to change the content of that element, and one way to accomplish this is to change the .innerHTML property of the element. Another task is modifying some aspect of the style of the element. All the style properties of an element can be accessed with .style and then the property name. For example, the following code changes the background color of the &lt;body&gt; element. document.querySelector(&#39;body&#39;).style.backgroundColor = &#39;red&#39;; 1.2.3.3 Where does JavaScript go in a document? Like with CSS, there are several ways to include JavaScript in an .html document. 1.2.3.3.1 &lt;script&gt; tag with src attribute JavaScript can be stored in a separate .js file and then loaded into a document using the &lt;script&gt; tag. code.js function changeColor(){ if(document.querySelector(&#39;body&#39;).style.backgroundColor == &#39;white&#39;){ document.querySelector(&#39;body&#39;).style.backgroundColor = &#39;black&#39;; } else { document.querySelector(&#39;body&#39;).style.backgroundColor = &#39;white&#39;; } } webpage.html &lt;head&gt; &lt;script src=&quot;code.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; The src attribute provides the path to the .js file, relative to the location of the .html file that contains the &lt;script&gt; element. If the .html and .js files are in the same folder, then the filename alone is sufficient. The example above creates a function changeColor() which will change the background-color style rule for the &lt;body&gt; element every time it is called. If the current color is white then it changes to black; otherwise it changes to white. This function, once loaded via the &lt;script&gt; tag, can be called by other JavaScript code in the HTML document. 1.2.3.3.2 &lt;script&gt; tag with embedded content The &lt;script&gt; tag can also be used without the src attribute, placing the JavaScript directly inside the tag instead. &lt;head&gt; &lt;script&gt; function changeColor(){ if(document.querySelector(&#39;body&#39;).style.backgroundColor == &#39;white&#39;){ document.querySelector(&#39;body&#39;).style.backgroundColor = &#39;black&#39;; } else { document.querySelector(&#39;body&#39;).style.backgroundColor = &#39;white&#39;; } } &lt;/script&gt; &lt;/head&gt; This has the equivalent effect of the first example. The &lt;script&gt; tag does not necessarily need to appear in the &lt;head&gt; section. Often the &lt;script&gt; tag is placed after the end of the &lt;body&gt;, in order to have the content in the &lt;body&gt; tag load first. In the minimal HTML document, it would look like this. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;A bare-bones HTML document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; // JavaScript code can be placed here &lt;/script&gt; &lt;/html&gt; 1.2.3.3.3 In certain attributes Some HTML attributes support JavaScript code embedded right in the HTML tag declaration. However, this is mostly an outdated approach at this point, and this method is not recommended. It’s mentioned here in case you come across it. An example of this approach is the onclick attribute of a &lt;button&gt; element. &lt;button onclick=&quot;changeColor();&quot;&gt;Click me!&lt;/button&gt; Every time the button is clicked the JavaScript function changeColor will be called. This function would be defined in a &lt;script&gt; tag elsewhere in the document. The JavaScript code is not limited to calling a single function. In theory, many statements could be executed by the button click, but in practice most programmers find that trying to embed long bits of JavaScript in HTML attributes produces difficult to read code. "],["publishing-a-website.html", "1.3 Publishing a website", " 1.3 Publishing a website "],["tools-for-web-development.html", "1.4 Tools for web development", " 1.4 Tools for web development 1.4.1 Editor 1.4.2 Browser developer tools 1.4.3 SFTP client 1.4.4 Database client "],["the-jspsych-timeline.html", "2 The jsPsych Timeline", " 2 The jsPsych Timeline This chapter describes… "],["setting-up-your-first-experiment.html", "2.1 Setting up your first experiment", " 2.1 Setting up your first experiment This section is a mini-tutorial that explains how to setup a very basic jsPsych experiment. The goal is to quickly get an experiment running so that you can see what a complete working experiment involves. Explanations of why certain steps are being taken are deliberately brief, and subsequent sections of this chapter will go into more detail. 2.1.1 Step 1. Create a folder for your experiment. Pick any location on your computer and create a new folder. You can call the folder whatever you like, such as FirstExperiment. Inside this folder create another folder called jspsych. 2.1.2 Step 2. Download the jsPsych library. The jsPsych library is hosted on GitHub at https://github.com/jspsych/jspsych. You can download the latest release on the releases page of the GitHub repository. Under each release you will see three files. Two are Source Code (zip) and Source Code (tar.gz). The other begins with jspsych- and ends with a version number. At the time of writing, the current release is v6.0.5 so the file to download is jspsych-6.0.5.zip. Once this file has downloaded, open the ZIP archive and move all of the files to the jspsych folder that you created in the previous step. 2.1.3 Step 3. Create a new HTML file. Open your coding-friendly text editor of choice (see SECTION 1.XXX if you don’t have an editor) and create a new file. In this file, create a [minimal HTML] document using the following code. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; &lt;/script&gt; &lt;/html&gt; Save this file as experiment.html inside the FirstExperiment folder. image or outline of directory structure here? 2.1.4 Step 4. Load the jsPsych library. Recall from SECTION XXX that JavaScript can be loaded from external .js files by including a &lt;script&gt; tag in the &lt;head&gt; section of an HTML document. To load jsPsych, add a &lt;script&gt; tag to the experiment.html file, with the src attribute linking to the jspsych.js file in the jspsych folder. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;jspsych/jspsych.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; &lt;/script&gt; &lt;/html&gt; A few things to be aware of when loading files in your experiment. 1. Make sure that the file paths in your HTML file match the exact names and locations of your files, including the letter capitalization (lowercase vs uppercase). 2. The file paths in your HTML file are relative to the location of your HTML file. The example above assumes that this HTML file is located in the top level of your main experiment directory, and that this directory also includes a folder called ‘jspsych’, which contains all of the jspsych files. If this is not the directory struture that you’re using, then you will need to modify the file paths in your HTML file accordingly. At least one plugin file is required to create an experiment. Load the html-button-response plugin by adding a &lt;script&gt; tag that points to the jspsych-html-button-response.js file in the jspsych/plugins folder. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;jspsych/jspsych.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jspsych/plugins/jspsych-html-button-response.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; &lt;/script&gt; &lt;/html&gt; Note that plugins should always be loaded after the main jspsych.js file is loaded. 2.1.5 Step 5. Create a welcome screen. This simple experiment will show a single screen, welcoming the participant to the experiment. There will be a button that the participant can click to continue (which will end the experiment). To create the welcome screen, create a JavaScript object called welcome. The object needs a few parameters, shown below. This code should be placed inside the &lt;script&gt;&lt;/script&gt; section of the HTML file. var welcome = { type: &#39;html-button-response&#39;, stimulus: &#39;Welcome to the experiment!&#39;, choices: [&#39;Continue&#39;] } The type parameter tells jsPsych which plugin is being used to construct the trial. In Step 4, you added a &lt;script&gt; tag to load the html-button-response plugin, and now the plugin is being used to construct this trial. Each plugin has a set of parameters. Two of the parameters for the html-button-response plugin are stimulus and choices. stimulus controls what content is displayed on the screen above the button. The plugin expects the stimulus to be a string, which may include HTML tags. choices is an array of labels for one or more buttons. In this example, there is a single button with the label 'Continue'. 2.1.6 Step 6. Create a timeline and add the welcome screen. A jsPsych experiment is defined by its timeline. The timeline is covered in depth later in this chapter. For now, think of the timeline as an ordered list of trials. After a trial is complete, the experiment progresses to the next trial in the timeline. The jsPsych timeline is created by adding trial objects, like the welcome object above, to an array. After the code above that defines the welcome trial, create an empty array called timeline, and then add the welcome object into the timeline array like this: var timeline = []; timeline.push(welcome); 2.1.7 Step 7. Start the experiment! Once you’ve created a timeline array that contains one or more trials, you can run the experiment. To start the experiment, call the function jsPsych.init(). This function takes an object of parameters. The only required parameter is timeline. The value of this parameter is the array of trials that you created in the previous step. jsPsych.init({ timeline: timeline }); 2.1.8 The completed experiment. Here’s what the completed HTML file looks like: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;jspsych/jspsych.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jspsych/plugins/jspsych-html-button-response.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; var welcome = { type: &#39;html-button-response&#39;, stimulus: &#39;Welcome to the experiment!&#39;, choices: [&#39;Continue&#39;] } var timeline = []; timeline.push(welcome); jsPsych.init({ timeline: timeline }); &lt;/script&gt; &lt;/html&gt; You can run the experiment by opening the experiment.html file with a web browser. The window below shows a running version of the experiment. Add live demo here "],["how-does-a-jspsych-experiment-work.html", "2.2 How does a jsPsych experiment work?", " 2.2 How does a jsPsych experiment work? As shown in the previous section, experiments in jsPsych are created by specifying a timeline. Timelines contain a set of ordered trials, and each trial is associated with a particular plugin. When the experiment runs, the core jsPsych code (in jspsych.js) parses the timeline to determine what trials should run during the experiment. The jsPsych code then calls the plugin for the first trial, passing it all the parameters specified in the trial object, and the plugin gains control of the experiment. The plugin then specifies what happens during the trial, including the presentation of any stimuli and collection of responses. When the trial is done, the plugin sends control back to the core jsPsych library to determine what the next trial is, and which plugin should have control next. This continues until all of the trials in the timeline array have finished. add some kind of a visual representation of a timeline of trials? This section goes into detail about basic features of plugins and timelines. Advanced features are covered in later chapters with experiments that require more complicated timeline and plugin designs. 2.2.1 Plugins Plugins define a basic framework for trials, tasks, or events that can be used in a jsPsych experiment. Some plugins define very general events, like displaying text and recording a keyboard response, or playing a sound file and recording a button response. Other plugins are more specific, like those that display particular kinds of stimuli (e.g. Random-Dot Kinematogram, visual search circle), or run a specific version of particular kind of task (e.g. the Implicit Association Test). Creating an experiment with jsPsych involves figuring out which plugins are needed to create the tasks you want your participants to perform. Plugins provide a basic structure for running a particular trial and collecting a response, but they generally allow for significant customization and flexibility through the use of parameters. For example, the image-keyboard-response plugin defines a simple structure for showing an image and collecting a keyboard response. You can specify the what the stimulus is, what keys the subject is allowed to press, and how long the stimulus should be on the screen, how long the subject has to respond, and so on. Many of these options have reasonable default values; even though the image plugin has many different parameters, you only need to specify the image stimulus in order to use it. Each plugin has its own documentation page, which describes (1) what the plugin does, (2) what parameters (options) are available (including whether the parameter is required or optional, and what its default value is), and (3) what kind of data the plugin collects. The plugin documentation pages can be found in the “Plugins” section of the jsPsych website. You can find an up-to-date list of plugins here: https://www.jspsych.org/plugins/list-of-plugins/. Often the easiest way to understand what each plugin does is to run its example file. Each plugin has its own example HTML file in the jspsych/plugins folder. If you open an example file in your web browser, you will see a live demo of a few basic trials using that plugin. You can also open the HTML file in your text editor to see the code that is used to run the example trials. One of the great things about plugins is that they can be modified, and you can create your own custom plugins. The official set of jsPsych plugins provide enough flexibilty and breadth to cover an enormous range of possible tasks and experiments. But if your experiment requires something that can’t be achieved using existing plugins, you can always opt to modify or create plugins, and therefore still take advantage of the general jsPsych framework for managing the experiment timeline and data. This will be covered in CHAPTER XXX. 2.2.1.1 Using a plugin To use a plugin, you’ll need to load the plugin’s JavaScript file in your experiment’s HTML page. All jsPsych experiments also need to load the “jspsych.js” file before any plugin files. &lt;head&gt; &lt;script src=&quot;jspsych/jspsych.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jspsych/plugins/jspsych-image-keyboard-response.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; Once a plugin is loaded, you can define a trial that uses that plugin. All jsPsych trials must have a type, which tells jsPsych what plugin to use to run the trial. The trial’s type is the plugin name, which usually the same as the plugin file name, but without the “jspsych-” prefix. The following JavaScript code defines a trial using the image-keyboard-response plugin to display an image file. This trial uses the default values for all of the other parameters, such as the valid key choices, stimulus duration, and trial duration. var image_trial = { type: &#39;image-keyboard-response&#39;, stimulus: &#39;images/happy_face.jpg&#39; } You can override any default parameter values by adding them into your trial object. Here’s an exampe of overriding the default values for trial_duration, choices, and post_trial_gap. Unlike the previous example trial, this trial will only accept the “h” and “s” keys as valid responses (choices parameter), and it will automatically end after 3 seconds if no valid response is made before then (trial_duration parameter). There will be a 2 second delay between the end of this trial and the start of the next one (post_trial_gap parameter). var image_trial = { type: &#39;image-keyboard-response&#39;, stimulus: &#39;images/happy_face.jpg&#39;, trial_duration: 3000, choices: [&#39;h&#39;,&#39;s&#39;], post_trial_gap: 2000 } what every plugin does (start, stop, collect data) kinds of plugins advantages of generic and specific plugins how to use a plugin docs and syntax default parameters 2.2.2 The timeline array of trials executed in order how to create a timeline in code (style guide). repeating trials (timeline node with repetitions parameter) pointer to advanced features (single paragraph). 2.2.3 Static and dynamic parameters Move this to its own chapter? In a typical declaration of a jsPsych trial, the parameters values are known at the start of the experiment. These are called static parameters, because the value is known in advance and does not change. This makes it impossible to alter the content or nature of the trial based on things that happen during the experiment. However, most trial parameters can also be specified as functions. When functions are used as the parameter value, the function is evaluated during the experiment, right before the trial starts, and the return value of the function is used as the parameter value for that trial. This enables dynamic updating of trial parameters based on data that a subject has generated, or any other information that you do not know before the experiment has started. Below is a sketch of how this can be used to display feedback about a participant’s response. This feedback trial uses the html-keyboard-response plugin to display text to the participant indicating whether their response in the last trial was correct or incorrect. var feedback = { type: &#39;html-keyboard-response&#39;, stimulus: function(){ var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct; if (last_trial_correct) { return &quot;Correct!&quot;; } else { return &quot;Wrong.&quot;; } }, choices: jsPsych.NO_KEYS } It’s fine if you don’t understand exactly what this code is doing - some of this will be explained in later chapters. The important thing to note here is that the stimulus parameter isn’t a normal text string, like we’ve seen in previous example trials. Instead, it’s a function, which uses the syntax function() { }. When functions are used as trial parameters, they will be typically written like this: stimulus: function() { // code here... } In the feedback trial example, the code inside the stimulus function first checks whether the last response was correct or incorrect, and then uses that information to return one of two different text strings: “Correct! if the response was correct, or”Wrong.\" if it was incorrect. The return keyword is used to return a value from a function. KEY IDEA: most of the code that you are writing runs before the experiment even begins. need simple situation where we want dynamic parameter (but need a few more concepts… so maybe this moves to next chapter, and we do big 5 there. or do it again? "],["experiment-demographics-questionnaire.html", "2.3 Experiment: Demographics questionnaire", " 2.3 Experiment: Demographics questionnaire Key topics covered: - Defining trials using jsPsych plugins - Adding trials to the timeline - Running the experiment "],["timeline-variables.html", "3 Timeline Variables ", " 3 Timeline Variables "],["timeline-variables-1.html", "3.1 Timeline Variables", " 3.1 Timeline Variables A common pattern in behavioral experiments is to repeat the same procedure many times, but with slightly different parameters across trials. A procedure might be a single trial, but it also might be a series of trials. Often the parameter that changes across trials is the stimulus, and you may also want to save other information to the trial data that varies across trials, such as the condition and correct response. jsPsych provides a short-cut solution to this with timeline variables. Timeline variables allow you define the procedure once (as a timeline) and specify a set of parameters and their values for each iteration through the timeline. Here is an example of how to use timeline variables. Suppose we want to create an experiment where people see a set of faces. Perhaps this is a memory experiment and this is the phase of the experiment where the faces are being presented for the first time. In between each face, a fixation cross is displayed on the screen. Without timeline variables, we would need to add many separate trials to the timeline, alternating between trials showing the fixation cross and trials showing the face. This could be done efficiently using a loop or function, but timeline variables make it even easier - as well as adding extra features like sampling and randomization. Here’s a basic version of the face presentation task with timeline variables. var trial_info = [ {face: &#39;person-1.jpg&#39;}, {face: &#39;person-2.jpg&#39;}, {face: &#39;person-3.jpg&#39;}, {face: &#39;person-4.jpg&#39;} ]; var fixation = { type: &#39;html-keyboard-response&#39;, stimulus: &#39;+&#39;, choices: jsPsych.NO_KEYS, trial_duration: 500 }; var face_trial = { type: &#39;image-keyboard-response&#39;, stimulus: jsPsych.timelineVariable(&#39;face&#39;), choices: jsPsych.NO_KEYS, trial_duration: 2500 }; var face_procedure = { timeline: [fixation, face_trial], timeline_variables: trial_info } Another way to write this same face_procedure is to define the timeline and timeline_variables arrays inside the procedure object itself, rather than defining them as variables and referencing the variable names. var face_procedure = { timeline: [ { type: &#39;html-keyboard-response&#39;, stimulus: &#39;+&#39;, choices: jsPsych.NO_KEYS, trial_duration: 500 }, { type: &#39;image-keyboard-response&#39;, stimulus: jsPsych.timelineVariable(&#39;face&#39;), choices: jsPsych.NO_KEYS, trial_duration: 2500 } ], timeline_variables: [ {face: &#39;person-1.jpg&#39;}, {face: &#39;person-2.jpg&#39;}, {face: &#39;person-3.jpg&#39;}, {face: &#39;person-4.jpg&#39;} ] } The two methods for creating the face_procedure above do exactly the same thing. It doesn’t make any difference which method you use - it’s just a matter of personal preference. The timeline_variables parameter is an array that contains one or more objects, where each object contains the information that is specific to a single “trial” (iteration through the timeline). When a procedure object is created that contains a timeline and timeline_variables, then jsPsych will repeat that timeline once for every object in the timeline_variables array. The face procedure timeline contains a fixation cross presentation for 500ms, followed by an image presentation for 2500ms. This procedure will repeat four times, once for each object in the timeline_variables array. The timeline variables are referenced wherever they’re needed in the trial parameters. Instead of using a fixed parameter value, if the value should be taken from the timeline variables, then you can call the jsPsych.timelineVariable() method and pass in the name of the variable. In this example, the only parameter that changes across trials is the image file that is presented. The image file is stored inside the timeline_variables array, in a variable called ‘face’. So whenever we want this variable to be used as a trial parameter, we would use jsPsych.timelineVariable('face'). Note that the name you use for the variables (e.g. ‘face’) doesn’t matter - you can use whatever names you want for your variables, as long as they are consistent in the timeline_variables objects and when they’re referenced in the trial parameters with jsPsych.timelineVariable(). What if we wanted the stimuli to be a little more complex, with a name displayed below each face? Let’s also add an additional step where the name is displayed for 1 second prior to the face appearing (maybe this is one condition of an experiment investigating whether the order of name-face or face-name affects memory encoding). Here are the changes we need to make: In the timeline_variables array, we need to add a name for each image. In the timeline array, we need to add another trial object to show the name on its own, before the face image. Because the name stimulus is text, we can use the html-keyboard-response plugin for this. The stimulus parameter should be the name associated with the image for this trial, which is the ‘name’ variable in the timeline variables objects. So the value of the stimulus parameter is jsPsych.timelineVariable('name'). The other parameters will be the same across all trials: a duration of 1000 ms, and no valid key choices. In the image trial, in addition to using jsPsych.timelineVariable('face') as the stimulus parameter value, we’ll add the prompt parameter, which allows you to show HTML-formatted text along with the image. The value of the prompt parameter will be that name that corresponds to the image in the timeline variables array: jsPsych.timelineVariable('name'). var face_name_procedure = { timeline: [ { type: &#39;html-keyboard-response&#39;, stimulus: &#39;+&#39;, choices: jsPsych.NO_KEYS, trial_duration: 500 }, { type: &#39;html-keyboard-response&#39;, stimulus: jsPsych.timelineVariable(&#39;name&#39;), trial_duration: 1000, choices: jsPsych.NO_KEYS }, { type: &#39;image-keyboard-response&#39;, stimulus: jsPsych.timelineVariable(&#39;face&#39;), prompt: jsPsych.timelineVariable(&#39;name&#39;), choices: jsPsych.NO_KEYS, trial_duration: 2500 } ], timeline_variables: [ {face: &#39;person-1.jpg&#39;, name: &#39;Alex&#39;}, {face: &#39;person-2.jpg&#39;, name: &#39;Beth&#39;}, {face: &#39;person-3.jpg&#39;, name: &#39;Chad&#39;}, {face: &#39;person-4.jpg&#39;, name: &#39;Dave&#39;} ] } "],["combining-timeline-variables-and-static-information.html", "3.2 Combining timeline variables and static information", " 3.2 Combining timeline variables and static information Example here showing how to incorporate timeline variables and other info in a dynamic parameter? Or save this for separate chapter on dynamic parameters? "],["experiment-the-big-5-personality-inventory.html", "3.3 Experiment: The Big 5 Personality Inventory", " 3.3 Experiment: The Big 5 Personality Inventory Big 5: https://www.ocf.berkeley.edu/~johnlab/bfi.php ? Big 5 extra short: http://www.colby.edu/psych/personality-lab/ Lots of choices: https://guides.library.uwa.edu.au/c.php?g=783318&amp;p=5612114 Code outline: - Welcome - Create array of questions - Create likert scale - Survey likert trial to show question and scale - Questionnaire procedure using timeline variables - End page Key topics covered: - Creating a procedure that is repeated over trials with slightly different parameters Other topics covered: - Creating a welcome page - Creating an end page "],["experiment-paired-associate-learning.html", "3.4 Experiment: Paired-Associate Learning", " 3.4 Experiment: Paired-Associate Learning The participant is asked to learn the associations between unrelated items, such as words (e.g. stove - letter). Present each word pair for a fixed duration, with randomized order and repeated presentations. Typically the participant is tested on their memory for the pairs, e.g. by presenting one item from the pair and asking them to recall the other. - Skip the test phase? - Use a small stimuli set that’s written out as a JavaScript array (skip the CSV-to-JSON conversion - this will be covered later). Code outline: - Instructions - Array with trial variables (word 1 and word 2) - Word pair trial - Word pair procedure with timeline variables, randomize_order: true, repetitions: N - End page Key topics covered: - Creating a procedure that is repeated over trials with slightly different parameters - Repeating over the same set of trial variables - Randomizing the trial order Other topics covered: - Creating instructions pages - Creating an end page "],["working-with-jspsych-data.html", "4 Working with jsPsych data", " 4 Working with jsPsych data When working with data, we want to access the data after it’s been collected. That is, the code that is used to access the data must run during the experiment or after it has finished, rather than when the page first loads. This means that we cannot access data in our main experiment script, because that code will run immediately when the page first loads, and there is no data at that point. (Example with code?) Instead, the code to access the data must go inside of a parameter function that is called at a specific point during the experiment, or after the experiment has finished. This chapter does not include a detailed explanation of the way that these parameter functions work, because this chapter is focused on the structure of jsPsych data and the tools that jsPsych provides for working with data. Throughout this chapter, you can simply ignore the fact that the data functions are placed inside of parameter functions, as this will be covered in CHAPTER XXX and CHAPTER XXX. "],["the-structure-of-jspsych-data.html", "4.1 The Structure of jsPsych Data", " 4.1 The Structure of jsPsych Data JavaScript array of objects, more flexible than tabular (e.g. CSV data) Each object in the array contains data from a single trial (plugin), in chronological order as the trials were presented during the experiment The objects do not need to contain the same properties (columns/variables) - the type of data included in each trial will depend on the plugin that was used There are is some data that is collected by all plugins (trial_type, trial_index, etc.) Very simple example with a few trials, and one or two different plugins Annotated screenshots of JSON- and CSV-formatted data, in browser and files "],["displaying-the-data-in-the-browser.html", "4.2 Displaying the Data in the Browser", " 4.2 Displaying the Data in the Browser displayData function, JSON and CSV options Example "],["saving-the-data-locally.html", "4.3 Saving the Data Locally", " 4.3 Saving the Data Locally localSave function, JSON and CSV options Example "],["saving-the-data-to-a-server.html", "4.4 Saving the Data to a server", " 4.4 Saving the Data to a server Beyond the scope of this book, but maybe add a few examples? "],["working-with-data-during-the-experiment.html", "4.5 Working with Data During the Experiment", " 4.5 Working with Data During the Experiment jsPsych.data.get() function, and briefly mention similar functions (getLastTimelineData, getLastTrialData) Functions for working with data collections, with basic examples Accessing responses from the trial data: need to know the format of the data for that trial, since the trial data properties and structure differ depending on the plugin - see plugin docs Basic example of accessing responses Using the trial’s data parameter to add flags for easier filtering Basic example of adding flags and filtering on those flags "],["experiment.html", "4.6 Experiment:", " 4.6 Experiment: Need something simple that requires the use of the participant’s previous responses/data. Also reference experiments from other chapters that include data manipulation "],["dynamic-parameters.html", "5 Dynamic Parameters ", " 5 Dynamic Parameters "],["experiment-stroop.html", "5.1 Experiment: Stroop", " 5.1 Experiment: Stroop Code outline: - Instructions - Array of trial variables: word/color combinations (create dynamically or hard-code?) - Stroop trial - dynamic stimuli parameter that combines word and color info from timeline variables into HTML string - Feedback trial - dynamic stimuli parameter that checks accuracy of previous trial, and shows correct/incorrect text - Stroop procedure: stroop and feedback, with timeline variables - End page Key topics covered: - Using dynamic parameters and HTML/CSS to dynamically create the stimuli Other topics covered: - Manipulating the jsPsych data "],["event-related-callback-functions.html", "6 Event-Related Callback Functions ", " 6 Event-Related Callback Functions "],["experiment-flanker.html", "6.1 Experiment: Flanker", " 6.1 Experiment: Flanker Code outline: - Create flanker task with timeline variables - Use trial’s on_finish function to score each response - Show correct/incorrect feedback after each response - Show performance summary at the end Key topics covered: - Event-related callback functions - Scoring each response during the task Other topics covered: - Manipulating the jsPsych data - Using dynamic parameters (stimulus) to show feedback after each response - Using dynamic parameters (stimulus) to show a performance summary "],["conditional-nodes-and-loop-nodes.html", "7 Conditional Nodes and Loop Nodes", " 7 Conditional Nodes and Loop Nodes Add visual representation of conditionals and loops using a decision tree/flow chart structure Quick examples: - Conditional ‘please respond faster’ message - Loop over missed/wrong trials? Note that when loops and conditionals are used, the number of rows in the data may not be the same across participants. The data is only saved from the trials that actually run, so some participants may have more/fewer rows in their data, depending on whether conditionals ran, and how many times a loop repeated. "],["experiment-lexical-decision-with-semantic-priming.html", "7.1 Experiment: Lexical Decision with Semantic Priming", " 7.1 Experiment: Lexical Decision with Semantic Priming This is a variant of the lexical decision task, in which participants are shown pairs of words. One word is shown briefly, followed by another. The participant must decide as quickly as possible whether or not the second word is a real word. The key manipulation is the semantic relationship between the first and second word in each pair (word trials only). The stimuli are a set of ambiguous word primes (e.g. bark) that are paired with (1) a subordinate-related (e.g. tree), (2) dominant-related (e.g. dog), (3) unrelated (e.g. cap), or (4) non-word target. In this experiment, we will include a set of practice trials before the main task. In order to ensure that participants understand the instructions before starting the main task, they will need to respond correctly to at least 4 out of the 5 practice trials. If they make 3 or fewer correct responses during the practice phase, they will be shown a message indicating that they will need to repeat the practice, along with a reminder about the instructions. Code outline: - Instructions - Arrays of practice and main task trial variables - convert from CSV to JSON, read in head as JS files - Dynamically create timeline variable arrays from stimuli info (factorial function, etc.) - Create practice trial procedure - Loop node that checks practice trial performance - Conditional node with message: You must repeat the practice - Main task - End screen Key topics covered: - Using loop nodes to repeat a timeline, based on data collected during the experiment - Using conditional nodes to run or skip a timeline, based on data collected during the experiment - Combining loop and conditional nodes to repeat a set of practice trials until a minimum performance level is achieved Other topics covered: - Importing trial variables from a CSV file (CSV-to-JSON conversion) - Could pull the CSV/JSON conversion out of this chapter, but this doesn’t seem like a big enough thing to warrant its own chapter. Maybe an appendix? - Using JavaScript and jsPsych functions to dynamically create the full set of trial information - Pseudo-randomizing the trial order (shuffle trials with no repeats of the same prime word) - jsPsych data manipulation "],["experiment-digit-span.html", "7.2 Experiment: Digit Span", " 7.2 Experiment: Digit Span Visual digit span with stop rule: 3 trials per list length, loop over list lengths, and repeat if at least one correct response out of the last 3 trials, otherwise stop the task Code outline: - Instructions - Create or read in the digit sequences (3 trials per list length, from 3 to 12 digits) - Digit presentation trial - Either nested timeline (3 trials per list length, with 10 list lengths), or non-nested timeline (just the digit presentation trial)? - Loop over digit presentation trial(s), after the 3rd trial for each list length, check to see if at least one correct response from last 3 trials - either continue or stop - End screen "],["using-media-files-images-audio-and-video.html", "8 Using Media Files: Images, Audio, and Video ", " 8 Using Media Files: Images, Audio, and Video "],["experiment-matrix-reasoning.html", "8.1 Experiment: Matrix Reasoning", " 8.1 Experiment: Matrix Reasoning Each trial contains a matrix of shapes, with one cell missing. Below each matrix stimulus is a set of options for the shape that could fill the empty cell in the matrix. The participant must decide which option would correctly fit in the empty cell by examining the relationships across the shapes in the matrix. The participant responds by clicking on a shape option. open access MR stimuli: https://royalsocietypublishing.org/doi/full/10.1098/rsos.190232 Code outline: - Preload images (matrix and options) - Instructions - Practice? - Main task: timeline variables, randomize_order: false - End Key topics covered: - Preloading media files to prevent loading delays during the experiment - Embedding images in clickable buttons to create a forced-choice task Other topics covered: - Using CSS to control and modify the visual appearance of stimuli (image size, button position) "],["randomization-and-sampling.html", "9 Randomization and Sampling ", " 9 Randomization and Sampling "],["experiment-1.html", "9.1 Experiment:", " 9.1 Experiment: Something with fairly complex randomization and/or sampling, e.g. blocks with a specific number of trials per condition, but random trial-to-block assignment, and trials randomized within blocks. Maybe some other constraint, like no more than N repeats of a condition within a block? "],["controlling-visual-appearance.html", "10 Controlling Visual Appearance ", " 10 Controlling Visual Appearance "],["experiment-2.html", "10.1 Experiment", " 10.1 Experiment Would be nice to have an experiment here that depends critically on CSS, e.g. where relative position of elements on the page (images, buttons, etc.) is part of the experimental manipulation. Or maybe a manipulation that involves the element’s style, like size/color. "],["modifying-and-creating-plugins.html", "11 Modifying and Creating Plugins ", " 11 Modifying and Creating Plugins "],["experiment-3.html", "11.1 Experiment:", " 11.1 Experiment: Self-paced reading with moving window? Combine stimulus and response types that already don’t exist in a plugin, e.g. audio with free-text or multiple choice response? "],["jspsych-extensions.html", "12 jsPsych Extensions ", " 12 jsPsych Extensions "],["experiment-lexical-competition-with-the-visual-world-paradigm-eye-tracking.html", "12.1 Experiment: Lexical Competition with the Visual World Paradigm (eye-tracking)", " 12.1 Experiment: Lexical Competition with the Visual World Paradigm (eye-tracking) Participants are shown a 2x2 set of images on the screen and are simultaneously presented with a spoken sentence (e.g. The birthday cake will be ready as soon as he adds the candles). There is a key word, the target (e.g. candles), that is spoken at the end of the sentence and is presented as one of the images. The other 3 images are (1) a phonological competitor (e.g. candy), (2) a semantic competitor (e.g. frosting), and (3) an unrelated filler (e.g. tape). Eye-tracking data during this task reveals lexical prediction and competition during online sentence listening. Key topics covered: - Using the jsPsych eye-tracking extension "],["experiment-regressions-to-ambiguities-during-sentence-reading-mouseview.html", "12.2 Experiment: Regressions to Ambiguities During Sentence Reading (MouseView)", " 12.2 Experiment: Regressions to Ambiguities During Sentence Reading (MouseView) Participants are shown written sentences containing lexical-semantic ambiguities. Sometimes the end of the sentence disambiguates the ambiguous word (e.g. ball) toward the subordinate (less-frequent) meaning (e.g. “Sally worried that the ball was going to be too crowded.”) and sometimes the final word is compatible with the dominant meaning (“…too expensive”). These sentences are presented on the screen while using the MouseView extension, which tracks visual attention over time by hiding/blurring the page content but providing a small viewing window (aperture) that the participant controls with the mouse. The participant reads each sentence by positioning the mouse on the left-hand side of the sentence and moving it toward the right as they read. The dependent measure is the frequency of regressions back to the ambiguous word after reaching the disambiguating word at the end of the sentence. Key topics covered: - Using the jsPsych MouseView extension "],["incorporating-external-js-libraries.html", "13 Incorporating External JS Libraries ", " 13 Incorporating External JS Libraries "],["experiment-estimating-visual-perception-thresholds-with-an-random-dot-kinematogram-rdk-task.html", "13.1 Experiment: Estimating Visual Perception Thresholds with an Random-Dot Kinematogram (RDK) Task", " 13.1 Experiment: Estimating Visual Perception Thresholds with an Random-Dot Kinematogram (RDK) Task Present RDK trials with an adaptive staircase procedure. Trials begin with a high coherence level (easy, close to 1), and the coherence level on subsequent trials depends on performance: the task becomes more difficult after N correct responses, and becomes less difficult after N incorrect responses. This is used to estimate the coherence values that correspond to a particular performance level (e.g. 70% correct responses) for each participant. There are separate adaptive tracks and threshold estimates for two different conditions: low contrast (more similar dot and background colors) and high contrast (less similar colors). At the end of the task, a performance chart is shown with the conherence values across trials for the two conditions (low and high contrast). Key topics covered: - Using an adaptive staircase procedure with the jsStaircase library - Adding an interactive performance summary graph with Google Charts: https://developers.google.com/chart Other topics covered: - jsPsych data manipulation "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
